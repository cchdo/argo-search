{"version":3,"sources":["../node_modules/streamsaver/StreamSaver.js"],"names":["module","exports","mitmTransporter","supportsTransferable","ponyfill","window","WebStreamsPolyfill","isSecureContext","useBlobFallback","test","HTMLElement","safari","downloadStrategy","document","documentElement","style","streamSaver","createWriteStream","filename","options","size","opts","pathname","writableStrategy","undefined","readableStrategy","Number","isFinite","console","warn","highWaterMark","makeIframe","mitm","src","delegate","createDocumentFragment","popup","frame","open","loaded","isIframe","isPopup","remove","close","addEventListener","dispatchEvent","removeEventListener","postMessage","onReady","evt","source","Event","makePopup","bytesWritten","downloadUrl","channel","MessageChannel","encodeURIComponent","replace","escape","response","transferringReadable","Math","random","toString","slice","headers","args","port2","transformer","transform","chunk","controller","length","enqueue","location","href","flush","ts","TransformStream","readableStream","readable","port1","onmessage","data","download","once","chunks","writable","WritableStream","write","push","blob","Blob","type","link","createElement","URL","createObjectURL","click","abort","supported","version","full","major","minor","dot","Error","iframe","hidden","name","contentWindow","body","appendChild","Response","ReadableStream","navigator","err","fn","e","mc","Object","defineProperty","configurable","value","definition"],"mappings":"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","file":"static/js/4.f5084e83.chunk.js","sourcesContent":["/* global chrome location ReadableStream define MessageChannel TransformStream */\n\n;((name, definition) => {\n  typeof module !== 'undefined'\n    ? module.exports = definition()\n    : typeof define === 'function' && typeof define.amd === 'object'\n      ? define(definition)\n      : this[name] = definition()\n})('streamSaver', () => {\n  'use strict'\n\n  let mitmTransporter = null\n  let supportsTransferable = false\n  const test = fn => { try { fn() } catch (e) {} }\n  const ponyfill = window.WebStreamsPolyfill || {}\n  const isSecureContext = window.isSecureContext\n  let useBlobFallback = /constructor/i.test(window.HTMLElement) || !!window.safari\n  const downloadStrategy = isSecureContext || 'MozAppearance' in document.documentElement.style\n    ? 'iframe'\n    : 'navigate'\n\n  const streamSaver = {\n    createWriteStream,\n    WritableStream: window.WritableStream || ponyfill.WritableStream,\n    supported: true,\n    version: { full: '2.0.0', major: 2, minor: 0, dot: 0 },\n    mitm: 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0'\n  }\n\n  /**\n   * create a hidden iframe and append it to the DOM (body)\n   *\n   * @param  {string} src page to load\n   * @return {HTMLIFrameElement} page to load\n   */\n  function makeIframe (src) {\n    if (!src) throw new Error('meh')\n    const iframe = document.createElement('iframe')\n    iframe.hidden = true\n    iframe.src = src\n    iframe.loaded = false\n    iframe.name = 'iframe'\n    iframe.isIframe = true\n    iframe.postMessage = (...args) => iframe.contentWindow.postMessage(...args)\n    iframe.addEventListener('load', () => {\n      iframe.loaded = true\n    }, { once: true })\n    document.body.appendChild(iframe)\n    return iframe\n  }\n\n  /**\n   * create a popup that simulates the basic things\n   * of what a iframe can do\n   *\n   * @param  {string} src page to load\n   * @return {object}     iframe like object\n   */\n  function makePopup (src) {\n    const options = 'width=200,height=100'\n    const delegate = document.createDocumentFragment()\n    const popup = {\n      frame: window.open(src, 'popup', options),\n      loaded: false,\n      isIframe: false,\n      isPopup: true,\n      remove () { popup.frame.close() },\n      addEventListener (...args) { delegate.addEventListener(...args) },\n      dispatchEvent (...args) { delegate.dispatchEvent(...args) },\n      removeEventListener (...args) { delegate.removeEventListener(...args) },\n      postMessage (...args) { popup.frame.postMessage(...args) }\n    }\n\n    const onReady = evt => {\n      if (evt.source === popup.frame) {\n        popup.loaded = true\n        window.removeEventListener('message', onReady)\n        popup.dispatchEvent(new Event('load'))\n      }\n    }\n\n    window.addEventListener('message', onReady)\n\n    return popup\n  }\n\n  try {\n    // We can't look for service worker since it may still work on http\n    new Response(new ReadableStream())\n    if (isSecureContext && !('serviceWorker' in navigator)) {\n      useBlobFallback = true\n    }\n  } catch (err) {\n    useBlobFallback = true\n  }\n\n  test(() => {\n    // Transfariable stream was first enabled in chrome v73 behind a flag\n    const { readable } = new TransformStream()\n    const mc = new MessageChannel()\n    mc.port1.postMessage(readable, [readable])\n    mc.port1.close()\n    mc.port2.close()\n    supportsTransferable = true\n    // Freeze TransformStream object (can only work with native)\n    Object.defineProperty(streamSaver, 'TransformStream', {\n      configurable: false,\n      writable: false,\n      value: TransformStream\n    })\n  })\n\n  function loadTransporter () {\n    if (!mitmTransporter) {\n      mitmTransporter = isSecureContext\n        ? makeIframe(streamSaver.mitm)\n        : makePopup(streamSaver.mitm)\n    }\n  }\n\n  /**\n   * @param  {string} filename filename that should be used\n   * @param  {object} options  [description]\n   * @param  {number} size     depricated\n   * @return {WritableStream}\n   */\n  function createWriteStream (filename, options, size) {\n    let opts = {\n      size: null,\n      pathname: null,\n      writableStrategy: undefined,\n      readableStrategy: undefined\n    }\n\n    // normalize arguments\n    if (Number.isFinite(options)) {\n      [ size, options ] = [ options, size ]\n      console.warn('[StreamSaver] Depricated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else if (options && options.highWaterMark) {\n      console.warn('[StreamSaver] Depricated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else {\n      opts = options || {}\n    }\n    if (!useBlobFallback) {\n      loadTransporter()\n\n      var bytesWritten = 0 // by StreamSaver.js (not the service worker)\n      var downloadUrl = null\n      var channel = new MessageChannel()\n\n      // Make filename RFC5987 compatible\n      filename = encodeURIComponent(filename.replace(/\\//g, ':'))\n        .replace(/['()]/g, escape)\n        .replace(/\\*/g, '%2A')\n\n      const response = {\n        transferringReadable: supportsTransferable,\n        pathname: opts.pathname || Math.random().toString().slice(-6) + '/' + filename,\n        headers: {\n          'Content-Type': 'application/octet-stream; charset=utf-8',\n          'Content-Disposition': \"attachment; filename*=UTF-8''\" + filename\n        }\n      }\n\n      if (opts.size) {\n        response.headers['Content-Length'] = opts.size\n      }\n\n      const args = [ response, '*', [ channel.port2 ] ]\n\n      if (supportsTransferable) {\n        const transformer = downloadStrategy === 'iframe' ? undefined : {\n          // This transformer & flush method is only used by insecure context.\n          transform (chunk, controller) {\n            bytesWritten += chunk.length\n            controller.enqueue(chunk)\n\n            if (downloadUrl) {\n              location.href = downloadUrl\n              downloadUrl = null\n            }\n          },\n          flush () {\n            if (downloadUrl) {\n              location.href = downloadUrl\n            }\n          }\n        }\n        var ts = new streamSaver.TransformStream(\n          transformer,\n          opts.writableStrategy,\n          opts.readableStrategy\n        )\n        const readableStream = ts.readable\n\n        channel.port1.postMessage({ readableStream }, [ readableStream ])\n      }\n\n      channel.port1.onmessage = evt => {\n        // Service worker sent us a link that we should open.\n        if (evt.data.download) {\n          // Special treatment for popup...\n          if (downloadStrategy === 'navigate') {\n            mitmTransporter.remove()\n            mitmTransporter = null\n            if (bytesWritten) {\n              location.href = evt.data.download\n            } else {\n              downloadUrl = evt.data.download\n            }\n          } else {\n            if (mitmTransporter.isPopup) {\n              mitmTransporter.remove()\n              // Special case for firefox, they can keep sw alive with fetch\n              if (downloadStrategy === 'iframe') {\n                makeIframe(streamSaver.mitm)\n              }\n            }\n\n            // We never remove this iframes b/c it can interrupt saving\n            makeIframe(evt.data.download)\n          }\n        }\n      }\n\n      if (mitmTransporter.loaded) {\n        mitmTransporter.postMessage(...args)\n      } else {\n        mitmTransporter.addEventListener('load', () => {\n          mitmTransporter.postMessage(...args)\n        }, { once: true })\n      }\n    }\n\n    let chunks = []\n\n    return (!useBlobFallback && ts && ts.writable) || new streamSaver.WritableStream({\n      write (chunk) {\n        if (useBlobFallback) {\n          // Safari... The new IE6\n          // https://github.com/jimmywarting/StreamSaver.js/issues/69\n          //\n          // even doe it has everything it fails to download anything\n          // that comes from the service worker..!\n          chunks.push(chunk)\n          return\n        }\n\n        // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transfarable streams solvs this...\n        channel.port1.postMessage(chunk)\n        bytesWritten += chunk.length\n\n        if (downloadUrl) {\n          location.href = downloadUrl\n          downloadUrl = null\n        }\n      },\n      close () {\n        if (useBlobFallback) {\n          const blob = new Blob(chunks, { type: 'application/octet-stream; charset=utf-8' })\n          const link = document.createElement('a')\n          link.href = URL.createObjectURL(blob)\n          link.download = filename\n          link.click()\n        } else {\n          channel.port1.postMessage('end')\n        }\n      },\n      abort () {\n        chunks = []\n        channel.port1.postMessage('abort')\n        channel.port1.onmessage = null\n        channel.port1.close()\n        channel.port2.close()\n        channel = null\n      }\n    }, opts.writableStrategy)\n  }\n\n  return streamSaver\n})\n"],"sourceRoot":""}